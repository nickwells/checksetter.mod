package checksetter

import (
	"fmt"
	"go/ast"

	"github.com/nickwells/check.mod/v2/check"
)

const (
	intCFName = "check.Int"
	intCFDesc = "int check func"
)

type intCFMaker func(*ast.CallExpr, string) (check.ValCk[int], error)

var intCFArgsToFunc map[string]intCFMaker

func init() {
	intCFArgsToFunc = map[string]intCFMaker{
		"":                     makeIntCF,
		"int":                  makeIntCFInt,
		"int, int":             makeIntCFIntInt,
		intCFName + ", string": makeIntCFIntCFStr,
		intCFName + " ...":     makeIntCFIntCFList,
	}
}

var intCFNoParam = map[string]check.ValCk[int]{
	"OK": check.ValOK[int],
}

var intCFInt = map[string]func(int) check.ValCk[int]{
	"EQ":          check.ValEQ[int],
	"GT":          check.ValGT[int],
	"GE":          check.ValGE[int],
	"LT":          check.ValLT[int],
	"LE":          check.ValLE[int],
	"Divides":     check.ValDivides[int],
	"IsAMultiple": check.ValIsAMultiple[int],
}

var intCFIntInt = map[string]func(int, int) check.ValCk[int]{
	"Between": check.ValBetween[int],
}

var intCFIntCFStr = map[string]func(check.ValCk[int], string) check.ValCk[int]{
	"Not": check.Not[int],
}

var intCFIntCFList = map[string]func(...check.ValCk[int]) check.ValCk[int]{
	"And": check.And[int],
	"Or":  check.Or[int],
}

// makeIntCF returns an Int checker corresponding to the given name - this
// is for checkers that are named directly and are not generated by calling a
// function
func makeIntCF(_ *ast.CallExpr, fName string) (cf check.ValCk[int], err error) {
	errIntro := fmt.Sprintf("can't make the %s func: %s():",
		intCFName, fName)

	if f, ok := intCFNoParam[fName]; ok {
		return f, nil
	}

	return nil, fmt.Errorf("%s the name is not recognised", errIntro)
}

// makeIntCFInt returns an Int checker corresponding to the given name -
// this is for checkers that take a single integer parameter
func makeIntCFInt(e *ast.CallExpr, fName string) (cf check.ValCk[int], err error) {
	var i int
	errIntro := func() string {
		return fmt.Sprintf("can't make the %s func: %s(%d):",
			intCFName, fName, i)
	}
	defer func() {
		if r := recover(); r != nil {
			cf = nil
			err = fmt.Errorf("%s %v", errIntro(), r)
		}
	}()

	if err = checkArgCount(e, 1); err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}

	i, err = getArgAsInt(e, 0)
	if err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}

	if f, ok := intCFInt[fName]; ok {
		return f(i), nil
	}

	return nil, fmt.Errorf("%s the name is not recognised", errIntro())
}

// makeIntCFIntInt returns an Int checker corresponding to the given name
// - this is for checkers that take two integer parameters
func makeIntCFIntInt(e *ast.CallExpr, fName string) (cf check.ValCk[int], err error) {
	var i, j int
	errIntro := func() string {
		return fmt.Sprintf("can't make the %s func: %s(%d, %d):",
			intCFName, fName, i, j)
	}
	defer func() {
		if r := recover(); r != nil {
			cf = nil
			err = fmt.Errorf("%s %v",
				errIntro(), r)
		}
	}()

	if err = checkArgCount(e, 2); err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}

	i, err = getArgAsInt(e, 0)
	if err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}
	j, err = getArgAsInt(e, 1)
	if err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}

	if f, ok := intCFIntInt[fName]; ok {
		return f(i, j), nil
	}

	return nil, fmt.Errorf("%s the name is not recognised", errIntro())
}

// makeIntCFIntCFStr returns an Int checker corresponding to the given
// name - this is for checkers that take an Int check func and a string
// parameter
func makeIntCFIntCFStr(e *ast.CallExpr, fName string) (cf check.ValCk[int], err error) {
	var s string
	errIntro := func() string {
		return fmt.Sprintf("can't make the %s func: %s(%s, %s):",
			intCFName, fName, intCFName, s)
	}
	defer func() {
		if r := recover(); r != nil {
			cf = nil
			err = fmt.Errorf("%s %v", errIntro(), r)
		}
	}()

	if err = checkArgCount(e, 2); err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}

	icf, err := getFuncIntCF(e.Args[0])
	if err != nil {
		return nil, fmt.Errorf("%s can't convert argument %d to %s: %s",
			errIntro(), 0, intCFName, err)
	}
	s, err = getString(e.Args[1])
	if err != nil {
		return nil, fmt.Errorf("%s %s", errIntro(), err)
	}

	if f, ok := intCFIntCFStr[fName]; ok {
		return f(icf, s), nil
	}

	return nil, fmt.Errorf("%s the name is not recognised", errIntro())
}

// makeIntCFIntCFList returns an Int checker corresponding to the given
// name - this is for checkers that take a list of int check funcs
func makeIntCFIntCFList(e *ast.CallExpr, fName string) (cf check.ValCk[int], err error) {
	errIntro := "can't make the " + intCFName +
		" func: " + fName + "(" + intCFName + " ...):"
	defer func() {
		if r := recover(); r != nil {
			cf = nil
			err = fmt.Errorf("%s %v", errIntro, r)
		}
	}()

	fArgs := make([]check.ValCk[int], 0, len(e.Args))
	for i, argExpr := range e.Args {
		scf, err := getFuncIntCF(argExpr)
		if err != nil {
			return nil, fmt.Errorf("%s can't convert argument %d to %s: %s",
				errIntro, i, intCFName, err)
		}
		fArgs = append(fArgs, scf)
	}

	if f, ok := intCFIntCFList[fName]; ok {
		return f(fArgs...), nil
	}

	return nil, fmt.Errorf("%s the name is not recognised", errIntro)
}

// intCFParse returns a slice of int check functions and a nil error if
// the string is successfully parsed or nil and an error if the string
// couldn't be converted to a slice of check functions.
func intCFParse(s string) ([]check.ValCk[int], error) {
	elts, err := getElts(s, intCFDesc)

	if err != nil {
		return nil, err
	}

	rval := make([]check.ValCk[int], 0, len(elts))

	for _, elt := range elts {
		f, err := getFuncIntCF(elt)
		if err != nil {
			return nil, fmt.Errorf("bad function: %s", err)
		}
		rval = append(rval, f)
	}

	return rval, nil
}

// getFuncIntCF will process the expression and return an Int checker or
// nil
func getFuncIntCF(elt ast.Expr) (cf check.ValCk[int], err error) {
	defer func() {
		if r := recover(); r != nil {
			cf = nil
			err = fmt.Errorf("Cannot create the %s func: %v", intCFName, r)
		}
	}()

	switch e := elt.(type) {
	case *ast.Ident:
		return makeIntCF(nil, e.Name)
	case *ast.CallExpr:
		fd, err := getFuncDetails(e, intCFName)
		if err != nil {
			return nil, err
		}

		maker, ok := intCFArgsToFunc[fd.expectedArgs]
		if !ok {
			return nil, fmt.Errorf("%s has an unrecognised argument list: %s",
				fd.name, fd.expectedArgs)
		}

		return maker(e, fd.name)
	}
	return nil, fmt.Errorf("unexpected type: %T", elt)
}
